/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "messages.h"


#ifndef _MSC_VER
void OutputType_result_Initialize(OutputType_result* pVal)
{
    static OutputType_result ret = 
        {1,
            {
                0x00
            }
        };
    *pVal = ret;
}
#endif

 
flag OutputType_result_IsConstraintValid(const OutputType_result* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 256);
	*pErrCode = ret ? 0 : ERR_OutputType_result;

	return ret;
}

flag OutputType_result_Encode(const OutputType_result* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? OutputType_result_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 256);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag OutputType_result_Decode(OutputType_result* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 256);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	}

	return ret;
}
#ifndef _MSC_VER
void OutputType_command_Initialize(OutputType_command* pVal)
{
    static OutputType_command ret = 
        {1,
            {
                0x00
            }
        };
    *pVal = ret;
}
#endif

 
flag OutputType_command_IsConstraintValid(const OutputType_command* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 256);
	*pErrCode = ret ? 0 : ERR_OutputType_command;

	return ret;
}

flag OutputType_command_Encode(const OutputType_command* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? OutputType_command_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 256);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag OutputType_command_Decode(OutputType_command* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 256);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	}

	return ret;
}
#ifndef _MSC_VER
void OutputType_Initialize(OutputType* pVal)
{
    static OutputType ret = 
        {
            .invokeid = 0,
            .command = {1,
                {
                    0x00
                }
            },
            .result = {1,
                {
                    0x00
                }
            }
        };
    *pVal = ret;
}
#endif

 
flag OutputType_IsConstraintValid(const OutputType* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	if (ret) {
	    ret = OutputType_command_IsConstraintValid(&pVal->command, pErrCode);
	    if (ret) {
	        ret = OutputType_result_IsConstraintValid(&pVal->result, pErrCode);

	    }
	}

	return ret;
}

flag OutputType_Encode(const OutputType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? OutputType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode invokeid */
	    BitStream_EncodeUnConstraintWholeNumber(pBitStrm, pVal->invokeid);
	    if (ret) {
	        /*Encode command */
	        ret = OutputType_command_Encode(&pVal->command, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode result */
	            ret = OutputType_result_Encode(&pVal->result, pBitStrm, pErrCode, FALSE);

	        }
	    }
    }

	return ret;
}

flag OutputType_Decode(OutputType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode invokeid */
	ret = BitStream_DecodeUnConstraintWholeNumber(pBitStrm, &pVal->invokeid);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	if (ret) {
	    /*Decode command */
	    ret = OutputType_command_Decode(&pVal->command, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode result */
	        ret = OutputType_result_Decode(&pVal->result, pBitStrm, pErrCode);

	    }
	}


	return ret;
}
#ifndef _MSC_VER
void InputType_command_Initialize(InputType_command* pVal)
{
    static InputType_command ret = 
        {1,
            {
                0x00
            }
        };
    *pVal = ret;
}
#endif

 
flag InputType_command_IsConstraintValid(const InputType_command* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 256);
	*pErrCode = ret ? 0 : ERR_InputType_command;

	return ret;
}

flag InputType_command_Encode(const InputType_command* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? InputType_command_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 256);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag InputType_command_Decode(InputType_command* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 256);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	}

	return ret;
}
#ifndef _MSC_VER
void InputType_Initialize(InputType* pVal)
{
    static InputType ret = 
        {
            .invokeid = 0,
            .command = {1,
                {
                    0x00
                }
            }
        };
    *pVal = ret;
}
#endif

 
flag InputType_IsConstraintValid(const InputType* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	if (ret) {
	    ret = InputType_command_IsConstraintValid(&pVal->command, pErrCode);

	}

	return ret;
}

flag InputType_Encode(const InputType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? InputType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode invokeid */
	    BitStream_EncodeUnConstraintWholeNumber(pBitStrm, pVal->invokeid);
	    if (ret) {
	        /*Encode command */
	        ret = InputType_command_Encode(&pVal->command, pBitStrm, pErrCode, FALSE);

	    }
    }

	return ret;
}

flag InputType_Decode(InputType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode invokeid */
	ret = BitStream_DecodeUnConstraintWholeNumber(pBitStrm, &pVal->invokeid);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	if (ret) {
	    /*Decode command */
	    ret = InputType_command_Decode(&pVal->command, pBitStrm, pErrCode);

	}


	return ret;
}

